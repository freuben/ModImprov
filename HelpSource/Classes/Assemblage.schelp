class:: Assemblage
summary:: An Assembladge or Ndef based Mixer
related:: Classes/Ndef, Classes/BufferSystem
categories:: Libraries>Radicles

Description::

A class that for mixing differnet Ndefs and adding effects.


classmethods::

method::new

Create new Assemblage.

argument::
Number of tracks

argument::
Number of buses

argument::
Number of audio channels

argument::
Space type

instancemethods::

method::filter

argument::
Type of assembladge element (master, bus or track)

argument::
Assemblage element number

argument::
Filter slot number

argument::
Filter type

argument::
Extra arguments for filter synth

argument::
Buffer for filter (if required)

argument::
Data for filter (if required)


Examples::

code::

Ndef(\output).play;

Ndef(\output).fadeTime = 0.5;

Blocks //work a nit more on blocks, check the buffers in patterns and alloc

Radicles.lineSize;
Radicles.document;

/*a = Assemblage(6, 2, [2, 1, 2]);*/


a = Assemblage(6, 2);

a.inputs.dopostln;

Block.addNum(3, 2);

a.input(Block.ndefs[0], \track, 1);

Block.play(1, \sine, \nobuf, [220,0,0.4], \nodata);

SynthFile.read(\block, \sine).cs.includesString(10.asAscii)

ModMap.map(Block.ndefs[0], \freq, \sin, \freq1, [\freq, 1], lag: [\freq, 1]);

a.getTrackInput(\master);

a.getTrackInput(\track, 2);

a.trackNames;
a.getTrackInput(\bus, 2);
a.getTrackInput(\bus, 4);

a.getBuses.dopostln;

a.getTracks.dopostln;

a.getMaster.postln;


a = Assemblage(6, 2);

Block.addNum(3, 1);

a.setInputs(Block.ndefs, \track, 1);

Block.play(1, \sine, \nobuf, [220,0,0.4], \nodata);

ModMap.map(Block.ndefs[0], \freq, \sin, \freq1, [\freq, 1], lag: [\freq, 1]);

a.input(Block.ndefs[0], \bus, 1);

a.getInputs(\track1);
a.ndefs;

a.getAllInputs(true).dopostln;
a.getAllInputs(false).dopostln;

a.tracks[0][0]

a.respace(\spaceMaster);
a.findTrackArr(\spaceMaster);

a.tracks[0][0][1].cs;

"Asdf".find("a");

a.space

Ndef.ar(\input1, 1);
Ndef(\input1).mold(1);
Ndef.ar(\input2, 2);
Ndef(\input2).mold(1);

a.input(Ndef(\input1), \track, 1);

a.input(Ndef(\input2), \track, 1);

a.input([Ndef(\input1), Ndef(\input2)], \track, 1)

// Ndef(\spaceTrack1).getKeysValues;

//start work with buses
(
a.masterInput = a.masterInput.copyRange(1, a.masterInput.size-1); //get rid of track1 to master

a.input(a.masterInput, \master);
)

a = Assemblage(6, 2);

a.bus(1, 1, 1);
a.bus(2, 1, 1);

a.busArr;

a.bus(2, 2, 1);
a.bus(3, 2, 0.5);

a.busMix(1, 1, 0);
a.busLag(1, 1, 1);
a.busMix(1, 1, 1);
a.busMix(2, 1, 0.5);

Ndef(\bus1In).set(\vol1, 0.5, \vol2, 1);


Ndef(\bus1In).numChannels
Ndef(\bus1In).getKeysValues


a.input(Ndef(\busIt), \bus, 1);

a.getTrackInput(\bus, 1);

Ndef(\busIt).source.cs;

Ndef('track1').source.cs;

Ndef(\busIt).set(\vol1, 0.5);

Ndef(\busIt).getKeysValues;

Ndef(\busIt).set(\vol1, 0);

///

//filters



Radicles.new;
Radicles.fadeTime = 2;

a = Assemblage(6, 2);

Block.addNum(3, 1);

a.setInputs(Block.ndefs, \track, 1);

Block.play(1, \sine, \nobuf, [220,0,1], \nodata);

a.filter(extraArgs: [\pitchRatio, 2, \pitchDispertion, 0]);

Ndef('track1').set(\volume, -50); //change track vol

a.filters;

a.getTracks[0];

a.filter(\track, 1, 2, extraArgs: [\pitchRatio, 0.5, \pitchDispertion, 0.1]);

a.filters;

a.specs[1]
a.removeFilter(\track, 1, 1);

a.findTrackArr(\track1)

a.ndefs[0]
a.specs[1].flop[0]

a.removeTrackFilters(\track, 1);

a.removeTrackFilters(\master, 1);

a.filter(\master, 1, 2, extraArgs: [\pitchRatio, 0.5, \pitchDispertion, 0.1]);

a.filters;

a.removeAllFilters;

a.removeAllFilters(\track);

a.removeAllFilters(\master);

a.tracks[1][1][1]
a.specs[1][1][1]

a.specs[1].flop



a.filter(\bus, 2, 2, extraArgs: [\pitchRatio, 2, \pitchDispertion, 0]);

a.filter(\master, extraArgs: [\pitchRatio, 2, \pitchDispertion, 0]);

a.filter(\master, 1, 2, extraArgs: [\pitchRatio, 2, \pitchDispertion, 0.1]);

a.collectTrackArr(\filterTrack);
a.collectTrackArr(\filterTrack1);
a.collectTrackArr(\filterTrack2);
a.getTracks[0].dopostln;

SynthFile.read(\filter, \lpf).cs;

a.filter(filter: \lpf);
a.filters;

a.filter(\track, 1, 3, extraArgs: [\pitchRatio, 3.5, \pitchDispertion, 0.5]);
a.filters;

Ndef(\filterTrack1).set(\pitchRatio, 2);

Ndef(\filterTrack1).getKeysValues

a.tracks

a.ndefs;

Ndef(\track1).source.cs

Ndef(\track1).set(\volume, 0.ampdb);

Ndef(\track1).getKeysValues

////
//convolution reverb

a = Assemblage(6, 2);

Block.addNum(3, 1);

a.setInputs(Block.ndefs, \track, 1);

Block.play(1, \loop, \marilyn1);

// Ndef('spaceTrack1').set(\pan, 1);


a.filter(\track, 1, 1, \convrev1, data: [\convrev, \ortf_s1r1, 2048]);

a.filterBuff[0];

a.filter(\master, 1, 1, \convrev1, data: [\convrev, \ortf_s1r1, 2048]);

Ndef('track1').set(\volume, -30);

BStore.stores;

SynthFile.read(\block)

// BStore.removeID([\cue, \cue2, \marilyn1]);

////
a.ndefs.flop[1];


a.bus(1, 1, 0.5, false); //track number, bus number, mix, dirIn


block1 -> track1 -> master
block2 -> track2 -> master
block3 -> track3 -> master
block4 -> track4 -> master
input -> track5 -> master


//

//////
a = Assemblage(6, 2);

Block.addNum(3, 1);

a.setInputs(Block.ndefs, \track, 1);

Block.play(1, \sine, \nobuf, [440,0,1], \nodata);

Block.play(1, \loop, \marilyn1);

a.filter(\track, 1, 1, \pch, extraArgs: [\pitchRatio, 2, \pitchDispertion, 0]);

///////
//set filter arguments
(
{10.do{
a.setFilterTag(a.filters[0][0], \pitchDispertion, rrand(0.1,10), \spec);
	1.yield;
}}.fork
)

//set through code
a.setFilter(0,0,3); //straight values (filterIndex, keyIndex, value)
a.setFilter(0,\pitchDispertion,0.1); //also use key as symbol
a.setFilter(\filterTrack_1_1,1,1); //also use filterTag
a.setFilter([\track, 1, 1], \pitchDispertion, 0.3); //or array to determing which track


//set with spec
a.setFilterSpec(0,0,1,1,0); //with spec
a.setFilterSpec([\track, 1, 1], \pitchDispertion, 100.linlin(0,127,0,1)); //also work with array and filterTag

//get infomation about filter settings and spec
a.collectSpecArr(a.findFilterTag(\track, 1, 1))[0][1]; //get specs for filter
a.getFilterVals(\track, 1, 1);
a.findFilterTag(\track, 1, 1)
a.getFilterArgs(\track, 1, 1);
a.convFilterTag(a.findFilterTag(\track, 1, 1));
a.getFilterKeys(\filterTrack_1_1);

///////
//modulate filter

a.modFilterTag(\filterTrack_1_1, 0, \sin, [0.25, 2], [\freq, 0.3], {|val| val*0.5});

a.getFilterTag(0);
a.modFilterIndex(0, 0, \sin, [0.25, 2], [\freq, 0.3], {|val| val*0.5}, 1.15);

ControlFile.post(\map);

a.filterInfoToTag(0);
a.filterInfoToTag(\filterTrack_1_1);
a.filterInfoToTag([\track, 1, 1]);

a.modFilter(0, 0, \lfn2, [\freq, 2]);
a.getFilterKeys(\filterTrack_1_1);

a.modFilterCode(\track, 1, 1, \pitchRatio, \lfn2, [\freq, 2]);

a.modFilterCode(\track, 1, 1, \pitchDispertion, \lfn1, [\freq, 1]);

/////



::
